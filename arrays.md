#МАССИВЫ  
// Это я так делаю, и на момент написания комментария не планирую менять этот текст в сторону "так надо"

// Как минимум потому, что я не знаю как "надо"

// Для себя поделила это дело на блоки ибо с их порядком у меня беда, что плохо, но к счастью прокатывало.

// Обычно у меня это именно так.

Начинаем с короткого (в основном) ревью домашечки. Показать, где лишние переменные, где можно сделать оптимальнее. 

***
Иногда рассказать, как красивее оформлять код (а то нечитабельно капец, а вы об этом ни на одном занятии не акцентируете внимание. помимо всего прочего такой код путает школьников).  Знакомлю их с for потому что почему бы и нет (но только если понимаю, что это их не сильно пригрузит). 

***  

Потом переходим к самим массивам. 
Рассказываю, что иногда нужно создавать много переменных с одинаковым названием.
Набрать 
```
int a1;
int a2;
int a3;
```
и сказать, что так набирать большое количество переменных не удобно. А также  
```
int x = 1;
int ax;
```
в значении ``int a1;`` компьютер не воспринимает. Но есть такая штука, как массивы. Записывается она вот так: ``int a[10];``. Что она делает? Она создает 10 по сути разных переменных под общим названием "а", которые отличаются одна от другой индексами ( ``a[1], a[2]...``). Отличие от первого варианта в том, что при написании индекса слитно с названием переменной, компьютер воспринимает их как имеющие кардинально разные названия (a1, a2). В то время как такой формат записи ``a[1]`` позволяет отделить для компьютера название от самого индекса. таким образом в записи ``a[1]`` "1" - это самостоятельное число, которое в свою очередь может храниться в переменной
(
```
int i = 1;
a[i] = 3;
```
), может быть посчитано (``a[2-1] = 3;``) и т.д.
Каждая такая переменная называется ячейкой, и с каждой ячейкой можно работать как и с любой другой переменной:
```
int a[10];
cin >> a[1];
a[2] = 3;
a[3] = a[2] + 1;
cout << a[4]; // и т.д.
```

***

Это был пример того, как я это обьясняю и я уже не помню, как это преподносите вы. Это именно то "так надо", которое я не знаю, и поэтому не делаю.

Время от времени уточняем, все ли понятно. Обычно они не боятся задавать вопросы потому что индивидуальное же занятие уже, нема перед кем стесняться.

***
```
int a;
cout << a;
```
Что будет? - Ступор и потерявшийся взгляд. Ничего/а../ну или не а, там же нет кавычек/0 - то, что мне обычно отвечают. Запускаем, смотрим, видим стремную фигню. Рассказываю, что у компьютера понятия "пустота" не существует, поэтому в каждой переменной всегда лежит какое-то число. Мусор, пока мы туда не положим что-то нормальное. И если это одна переменная, мы можем и не провтыкать этот момент, но с массивами важно не забывать обнулять каждую ячейку.  
А как?  
Ну, вот и первое задание - обнулить массив и вывести его на экран, чтоб в этом убедиться.
Они такие чето делают, типа ``a[10] = 0; / int a[10] = 0; / a = 0; ``. Обнаруживают, что так нельзя. Спрашивают.  
// Сегодня меня девочка уламала рассказать ей про ``int a[10] = {0};``, но я ей сказала пока об этом забыть и страдать. Она отнеслась к этому с пониманием (или мне хотелось, чтоб она так к этому отнеслась).  
Объясняю, что массив, это просто 10 коробочек, которые лежат рядом и называются одинаково, но сказать "положи 0 во все коробочки" нельзя, а вот "в каждую"(что означает 10 раз выполнить присвоение) можно. Они либо же начинают писать чето типа 
```
a[1] = 0;
a[2] = 0;
a[3] = 0;
...
``` 
и я им говорю, чтоб сказали мне, когда им надоест делать одно и то же (что кстати может не сработать, если это кто-то типа Кати, которой не надоело и Роме пришлось сделать массив размером 100). Тогда объясняю, что в большинстве своем повторять одни и те же комманды много раз в программировании - плохая практика, и что практически всегда можно заставить компьютер делать это за тебя. Либо же они сразу пропускают последние два предложения. И тогда мы приходим к циклам, с помощью которых это все дело делается.
***

Вот на моменте циклов обычно разбираемся во-первых с тем, что программисты считают с нуля, поэтому в записи 
``int a[10];`` 10 - это количество/размер, и когда работаем с каждой переменной отдельно получается, что первой идет a[0], а десятой a[9]. Не знаю, со всеми ли так, но те, у кого я вела, отут сильно начинали втыкать на цыклах и с тем, как их крутить, откуда и куда, из-за этой путаницы с 0/1, 9/10.
***

Второе, к чему тоже обычно приходим на циклах, - выход за пределы массива. С многими получается легко, когда они себя сами к этому приводят такой записью:
```
int a[10];
int i = 0;
while (i < 10) {
	a[i] = 0;
	i++;
}
cout << a[10]; // почему так, если я вроде объяснила? не знаю, но так происходит у многих, может какой-то мой косяк.
```
В общем они благополучно видят там 10, я нормально так объясняю че так происходит. 
// Говорят, что норм, понятно. Хз, я вот 100% не вдупляла, что такое "выход за пределы массива" еще достаточно долго.
Если чуваки секут и не тупят с этим выводом на экран, то я сама их как-то привожу к ситуациям, когда выход за пределы таки есть. Энивей.
***

Могла что-то забыть, но обычно это происходит так. Потом даю им первую задачу из домашки, чтоб они освоились. Они страдают, но делают. Когда они показывают мне эту вымученную задачку, я даю им последнее микро-страдание, меняю размер массива, скажем, на 20. Они начинают быстренько менять весь свой код. Тогда объясняю, что это дело удобно хранить в какой-то переменной, чтоб ниче не провтыкать и просто было удобно. И очень быстро проходимся по остальной домашке, просто чтоб я убедилась, что они понимают, что там нужно будет сделать. На этом все. Вопросы?

#СТРОКИ
кек

